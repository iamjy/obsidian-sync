# Cypress FX3 I2C Core Clock Configuration

## 개요

Cypress FX3 USB 3.0 Controller의 I2C 마스터 모드에서 발생하는 클럭 설정 불일치 문제와 해결 방안에 대한 기술 문서입니다. M24M02-DRMN6TP EEPROM과의 통신에서 설정된 비트 전송률과 실제 측정값 간의 차이로 인한 불안정성을 분석하고 해결책을 제시합니다.

## 문제 상황

### 하드웨어 구성
- **MCU**: Cypress FX3 USB 3.0 Controller
- **EEPROM**: M24M02-DRMN6TP (256K-bit Serial I2C EEPROM)
- **통신 인터페이스**: I2C (FX3 Master 모드)

### 설정 vs 실측값 비교

| 항목 | 설정값 | 실측값 | 차이 |
|------|--------|--------|------|
| I2C 비트 전송률 | 400kHz | 300kHz | -100kHz (-25%) |
| I2C 코어 클럭 | 4MHz | 3MHz | -1MHz (-25%) |
| 분주비 (추정) | 96 | 128 | +32 (+33%) |

### 증상
- EEPROM 읽기 동작 불안정
- 간헐적 통신 오류 발생
- 데이터 무결성 문제 가능성

## 기술적 분석

### FX3 클럭 체인 구조

```
크리스탈 (19.2MHz) 
    ↓
sys_clk_pll (FBDIV=20, REFDIV0=0, OUTDIV=00)
    ↓
시스템 클럭 (384MHz)
    ↓
I2C 분주기 (GCTL_I2C_CORE_CLK)
    ↓
I2C 코어 클럭
    ↓
SCL 출력 (코어 클럭 ÷ 10)
```

### 클럭 계산

| 단계 | 계산식 | 설계값 | 실제값 |
|------|--------|--------|--------|
| 시스템 클럭 | 19.2MHz × 20 | 384MHz | 384MHz |
| 목표 분주비 | 384MHz ÷ 4MHz | 96 | 128 |
| 실제 코어 클럭 | 384MHz ÷ 128 | 3MHz | 3MHz |
| 실제 SCL | 3MHz ÷ 10 | 300kHz | 300kHz |

### EEPROM 사양과의 호환성

M24M02-DRMN6TP는 다음 비트 전송률에서만 동작을 보장합니다:

| 지원 주파수 | 현재 상태 | 호환성 |
|-------------|-----------|--------|
| 1MHz | - | ✅ 가능 |
| 400kHz | 설정값 | ✅ 목표 |
| 100kHz | - | ✅ 대안 |
| **300kHz** | **실측값** | ❌ **미지원** |

현재 300kHz로 동작하는 것은 EEPROM 사양 범위를 벗어나므로 통신 불안정의 근본 원인입니다.

## 원인 분석

### 1차 원인 (가장 유력)
**I2C 클럭 분주기 설정 오류**
- FX3 SDK의 `CyU3PI2cSetConfig()` 함수에서 분주비 계산 로직 오류
- 실제 분주비가 96 대신 128로 설정됨
- 결과적으로 목표 주파수의 75% 수준으로 동작

### 2차 원인 (가능성)
**하드웨어 로딩 효과**
- 과도한 풀업 저항값 (권장: 4.7kΩ)
- PCB 트레이스 캐패시턴스
- EEPROM 입력 캐패시턴스 (일반적으로 5-10pF)

이러한 요소들이 신호 슬루율을 저하시켜 유효 주파수를 감소시킬 수 있습니다.

### 3차 원인 (낮은 가능성)
**시스템 클럭 인식 오류**
- SDK에서 시스템 클럭을 384MHz가 아닌 다른 값으로 인식
- 결과적으로 잘못된 분주비 계산

## 해결 방안

### 즉시 조치 (안정성 확보)

```c
// 1. 100kHz로 낮춰 안정성 확보
CyU3PI2cConfig_t i2cConfig;
i2cConfig.bitRate = 100000;  // 100kHz (안전한 주파수)
i2cConfig.busTimeout = 0xFFFFFFFF;
i2cConfig.dmaTimeout = 0xFFFF;

CyU3PI2cSetConfig(&i2cConfig, NULL);
```

### 근본 해결 (원인별 접근)

#### A. 소프트웨어 수정
```c
// 직접 레지스터 제어로 정확한 분주비 설정
uint32_t target_core_clk = 4000000;  // 4MHz
uint32_t sys_clk = 384000000;        // 384MHz
uint32_t divider = sys_clk / target_core_clk;  // 96

CY_U3P_LPP->gctl_i2c_core_clk = divider;
```

#### B. 하드웨어 최적화
| 항목 | 권장값 | 확인사항 |
|------|--------|----------|
| 풀업 저항 | 4.7kΩ | 현재값 측정 |
| 트레이스 길이 | 최소화 | PCB 레이아웃 검토 |
| 바이패스 커패시터 | 100nF + 10nF | 전원 노이즈 제거 |

#### C. 검증 방법
```c
// 설정 후 실제 레지스터 값 확인
uint32_t actual_divider = CY_U3P_LPP->gctl_i2c_core_clk;
uint32_t actual_core_clk = 384000000 / actual_divider;

// 로그 출력으로 검증
CyU3PDebugPrint(4, "I2C Core Clock: %d Hz\n", actual_core_clk);
```

## 권장 구현 순서

### 1단계: 임시 안정화
- I2C 비트 전송률을 100kHz로 낮춤
- 통신 안정성 확인

### 2단계: 원인 규명
- GCTL_I2C_CORE_CLK 레지스터 값 직접 확인
- 하드웨어 신호 품질 측정 (오실로스코프)

### 3단계: 근본 해결
- 정확한 분주비로 레지스터 직접 설정
- 400kHz에서 안정성 테스트

### 4단계: 최적화
- 하드웨어 개선 (필요시)
- 1MHz 동작 테스트 (성능 향상)

## 결론

현재 300kHz로 동작하는 I2C는 EEPROM 사양을 벗어나므로 통신 불안정이 필연적입니다. 가장 유력한 원인은 FX3 SDK의 분주비 계산 오류로 보이며, 직접 레지스터 제어를 통해 정확한 클럭 설정이 가능합니다. 임시적으로는 100kHz로 낮춰 안정성을 확보하고, 근본적으로는 정확한 400kHz 설정을 통해 문제를 해결해야 합니다.

## 참고사항

- I2C 사양상 코어 클럭은 비트 전송률의 10배여야 함
- FX3는 I2C Master 모드에서만 동작
- M24M02-DRMN6TP는 Standard (100kHz), Fast (400kHz), Fast+ (1MHz) 모드 지원
- 클럭 설정 오류는 데이터 무결성에 직접적인 영향을 미침

---
*작성일: 2025-09-10*  
*기술 문서 버전: 1.0*