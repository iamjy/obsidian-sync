---
title:
source:
author:
published:
created: 2025-09-07
description:
tags:
---
# 포키의 의미

포키Poky는 욕토 프로젝트의 레퍼런스 시스템이며, 툴과 메타데이터의 집합으로 구성된다 . 포키는 플랫폼에 독립적이고 비트베이크, 오픈임베디드 코어와 메타데이터를 사용하여 다음 그림에 보이는 것처럼 크로스 컴파일을 수행한다.

![[Pasted image 20260105161800.png]]

# 타깃 이미지 빌드
포키는 이미지를 빌드하기 위해 몇몇의 미리 정의된 이미지 레시피recipe를 제 공한다
```
$: ls meta*/recipes*/images/*.bb
$: source oe-init-build-env
$: bitbake core-image-full-cmdline
```

# 메타데이터

클래스와 레시피는 실행될 태스크를 설명하고, bitbake가 **태스크 체인**을 만드는 데 필요한 정보를 제공한다. **상속 매커니즘**은 레시피가 하나 이상의 클래스를 상속받을 수 있게 하여 코드 중복을 줄이고 유지 보수를 쉽게 한다.

## 환경설정 ( .conf 파일 )

- 전역 변수들을 정의
- 전역 변수들을 이용해서 레시피에 정보를 전달하고 레시피가 어떻게 동작할지 결정한다.
- 일반적인 예는 하드웨어 보드에 관한 설정들을 갖고 있는 머신 파일이다.

## 클래스 ( .bbclass 파일 )

- 전체 시스템에서 사용
- 레시피들이 필요에 따라 상속받아 사용
- 기본값으로도 사용됨
- 예를 들어, kernel.bbclass는 리눅스 커널의 버전이나 벤더와는 무관하게 빌드 및 설치 프로세스를 진행하는데 도움을 준다.

## 레시피 ( .bbappend 파일 )

하나의 비트베이크 레시피(.bb)는 실행될 태스크의 논리적 단위이다.
비트베이크는 레시피 간 의존성 체인을 통해 모든 레시피를 빌드를 위해 필요 한 순서로 정리한다 . 이를 통해 비트베이크는 태스크를 다음과 같이 정리한다．
- 의존성이 없는 레시피들은 병렬로 빌드된다．
- 의존성이 있는 레시피들은 의존성을 만족시키는 방향으로 순차적으로 빌 드된다.

# 외부 레이어

레이어 타입과 폴더 구조가 동작하는 방식을 알아보고, 마지막으로 새 레이어를 프로젝트에 어떻게 포함하는지 알아보자.

## 레이어를 이용한 유연성 확보

다른 레이어의 레시피에서 제공되는 추가 기능들을 appends를 이용해 원하는 데로 수정하여 사용할 수 있다.

커스텀 프로젝트 환경을 만들 때 하나의 레이어에 모든 변경을 적용하면 안되고, 서로 다른 레이어에서 작업해야 한다. 예를 들어, 포키 소스 코드 자체도 서로 다른 레이어로 분리 되어 있다. 기본값으로 3개의 레이어를 포함 (meta, meta-yocto, meta-yocto-bsp) 한다.

### 소프트웨어 레이어

어떤 아키텍처에서도 이용될 수 있는 애플리케이션과 이를 위한 환경 설정 파일들을 포함한다. 소프트웨어 레이어는 매우 많은데, 몇몇만 나열해보면 meta-java, meta-qt5, meta-browser 등이 있다.

### BSP 레이어

meta-yocto-bsp 레이어는 포키의 레퍼런스 BSP 이다. 패키지들을 해당 머신에 적용하기 위한 머신 환경 설정 파일들과 레시피를 포함한다.

## 레시피 커스터마이즈

이미 존재하는 레시피를 수정해야 하는 경우, .bbappend 파일을 프로젝트 레이어에 만들어야 한다. 파일의 이름은 원본 레시피와 같고 append만 확장자에 추가된다.
예를 들어, 원본 레시피의 이름이 '(original-layer)/recipes-core/app./app_1.0.bb' 라면, 대응하는 bbappend 파일은 '(layer)/recipes-core/app/app_1.0.bbappend' 가 된다. 하나의 레시피에 한 개 이상의 .bbappend 파일이 있으면, 레이어의 우선순위에 따라 모두 적용된다.

### 패치 적용

이미 존재하는 패키지에 패치를 적용하고 싶은 경우에는 비트베이크 ( bitbake ) 의 검색 알고리즘에 새로운 폴더를 추가하는 FILESEXTRAPATHS 변수를 다음과 같 이 이용해야 한다
```
FILESEXTRAPATHS:prepend := "${THISDIR}/${PN}-${PV}:"
SRCURI += "file: //mypatch.patch"
```

### 존재하는 패키지에 추가 파일 적용

do_install_append 함수는 함수 내부의 코드 블록을 원본 do_install 함수의 메타데이터 밑에 붙인다.

```
FILESEXTRAPATHS prepend := "${THISDIR}/${PN}-${PV}:' 

SRC_URI += "file://newconfigfile.conf"

do install append() { install -m 644 ${WORKDIR}/newconfig.conf ${D}${sysconfdir} }
```

### 파일 탐색 경로

SRC_URI 에 일반 파일이나 패치가 포함되면, 비트베이크는 이 파일을 FILESPATH나 FILESEXTRAPATH 변수에 들어 있는 값의 경로에서 찾는다.

기본 검색 경로는 아래와 같다.

- recipe-version/
- recipe/
- files/

추가로 비트베이크 OVERRIDES 변수도 체크하여 오버라이드에 특화된 파일도 찾는다. 예를 들어 foo_1.0.bb가 있고, OVERRIDES = "(board):(arch)"라고 하면 다음 경로에서도 찾는다.

- foo_1.0/(board)
- foo_1.0/(arch)
- foo_1.0/
- foo/(board)
- foo/(arch)
- foo/
- files/(board)
- files/(arch)
- files/

### 레시피의 피처 변경

PACKAGECONFIG를 이용해 레시피의 피처를 활성화하거나 비활성화할 수 있다.

```
PACKAGECONFIG ?= "featurel"
PACKAGECONFIG[featurel] = "---enable-featurel, --disable featurel, featureldepends"
PACKAGECONFIG[feature2] = "--enable-feature2, --disable feature2, feature2depends"
```

다음 코드처럼 .bbappend 파일을 만들어 PACKAGECONFIG 변수의 기본 값에 feature2를 활성화하게 할 수 있다.

```
PACKAGECONFIG += "feature2"
```


# 사용자 레이어 생성

커뮤니티 또는 벤더에 의해 제공되는 기존 레이어를 사용하는 것을 넘어서 자신만의 제품을 위해 레이어를 추가하는 이유를 알아볼 것이다.

새로운 레이어를 생성하기 전에 항상 오픈임베디드 ( 0penEmbedded ) 메타데이터 ( metadata ) 인덱스（http://layers.openembedded.org）에 이미 이용 가능한 비슷한 레이어 가 있는지 확인하는 것이 좋다.

레이어 환경설정 파일은 모든 레이어에서 요구되고 ( layer )/conf/layer.conf에 위치한다

```
bitbake-layers add-layer meta-custom
```

## 패키지 레시피 추가

패키지 레시피는 비트베이크가 애플리케이션 , 커널 모듈 , 또는 프로젝트에 의 해 제공되는 어느 소프트웨어를 다운로드 , 압축풀기 , 컴파일 , 설치하는 방법을 제시한다.

```
DESCRIPTION = "Simple helloworid application" 
SECTION = "examples" 
LICENSE = "MIT" 
LIC FILES CHKSUM = "file://${COMMON LICENSE D IR}/MIT;md5=0835ade698e0b of 850 6ecda2f 7b4f 302 " 

SRC URI = "file://helloworld.c" 

S = "${WORKDIR}" 

do compile() { 
    ${CC} helloworld.c -o helioworld 
} 

do install () { 
    install -d ${D}${bindir} install -m 0755 helloworid ${D}${bindir} 
} 
```

포키는 Autotools, CMake와 QMake를 기반으로 하는 프로젝트들 로써 가장 흔한 개발 툴에 대한 처리를 추상화한 여러 클래스를 가지고 있다.

Autotools 기반 프로젝트의 경우, autotools 클래스를 사용하여 많은 코드 중복을 피할 수 있다.

```
DESCRIPTION = "A simple tool to wait for a specific signal over DBus" 
. . .
inherit autotools
```

같은 개념은 CMake와 QMake의 경우와 같이 다른 빌드 툴에도 적용된다 .

## 머신 정의 작성

머신에 필요한 정보를 제공하면 된다. 부트로더 커널, 하드웨어 지원 드라이버들은 BSP 레이어에서 보드에 통합하기 위해 시작전에 점검한다. 

머신 정의에서 사용되는 변수의 일반적인 집합은 다음과 같다. 

- TARGET ARCH: ARIVI과i586와 같은 머신 아키텍처를 설정한다. 
- PREFERRED PROVIDE_virtual/kernel: 특정한 커널을 사용하는 경우에 기본 커널（linux-yocto）를 덮어쓴다. 
- SERIAL- CONSOLES: 시리얼 콘솔과 속도를 정의한다. 
- MACHINE FEATURES: 필요한 소프트웨어 스택이 기본 이미지에 포함되도록 하드웨어 특성을 정의한다. 
- KERNEL IMAGETYPE: zlmage나 ulmage와 같은 커널 이미지 유형을 선택하 기 위해 사용한다. 
- IMAGE FSTYPES: tar.gz, ext4, ubifs와 같은 일반적인 파일시스템 이미지 유형을 선택한다. 

